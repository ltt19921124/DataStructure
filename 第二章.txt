	第二章
	2.5 算法的特性

	2.5.1 输入输出
	有零个或多个输入，最少一个或多个输出

	2.5.1 有穷性
	执行有限步骤后，会自动结束，不会无限循环

	2.5.2 确定性
	算法每一个步骤都具有确定的意义

	2.5.4 可行性
	算法的每一步都必须是可行的，每一步都能够通过执行有限次数完成
	
	2.6算法设计的要求
  	
  	
	2.6.1 正确性
	正确性是指算法至少应该具有输入、输出和加工处理无歧义性。

	2.6.2 可读性
	便于阅读、理解和交流

	2.6.3 健壮性
	当数据输入不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果

	2.6.4 时间效率高和存储量低
	好的算法还具有时间效率高和存储量低的特点

	2.7算法效率的度量方法
	2.7.1 事后统计方法
	主要是通过设计好的测试程序和数据，利用计算机计时器对不同的算法编制的程序
	的运行时间进行比较，从而确定算法效率的高低	

	2.7.2 事前分析估算方法
	事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算
	
	一个程序在计算机上运行时消耗的时间取决于下列因素
	1，算法采用的策略、方法
	2，编译产生的代码质量
	3，问题的输入规模
	4，机器执行指令的速度
	
	2.8 函数的渐进增长
	假设算法A要执行2n+3次操作，算法B要执行3n+1次操作。
	它们谁更快呢？
	
	显然答案不是一定的。
	n=1时，算法A不如算法B。当n=2时，两者效率相同。n>2时，算法A就开始优于算法B了
	随着n的增加，算法A 比算法B越来越好。于是我们得出结论：总体上算法A优于算法B
	此时我们给出这样的定义:输入规模n没有限制的情况下，只要超过一个数值N，这个函数
	就总是大于另一个函数，我们称函数时渐进增长的。

	函数渐进增长：给定两个函数：f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N,
	f(n)总是大于g(n),那么我们说f(n)的增长渐进快于g(n)。

	2.9 算法的时间复杂度

	T(n) = O(f(n)),语句的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化
	情况并确定T(n)的数量级。时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))
	随问题规模n的增大，算法执行时间的增长和f(n)的增长率相同，称作算法的渐进时间复杂度
	简称为时间复杂度。其中f(n)是问题规模n的某个函数。
	大O记法，一般情况下，随着n的增大，T(n）增长最慢的算法为最优算法。

	2.9.2 推到大O阶方法
	1，用常数1取代运行时间中所有的加法常数
	2,在修改后的运行次数函数中，只保留最高阶项
	3，如果最高阶项存在而且不是1，则去除与这个项相乘的常数，得到的结果就是大
	O阶。
	
	2.9.3 常数阶

	int sun = 0;n = 100;//执行一次
	sum = (1+n)*n/2;//执行一次
	printf(" %d ", sum);//执行一次

	这个算法运行次数就是f(n) = 3;根据大O记法，把3改为1，没有最高项阶，所以这个算法的
	时间复杂度为O(1)。

	int sum = 0, n = 100;//一次
	sum = (1+n)*n/2;//执行第1次
	sum = (1+n)*n/2;//执行第2次
	sum = (1+n)*n/2;//执行第3次
	sum = (1+n)*n/2;//执行第4次
	sum = (1+n)*n/2;//执行第5次
	sum = (1+n)*n/2;//执行第6次	
	sum = (1+n)*n/2;//执行第7次
	sum = (1+n)*n/2;//执行第8次
	sum = (1+n)*n/2;//执行第9次
	sum = (1+n)*n/2;//执行第10次
	
	无论n为多少，代码就是3次和12次的差异，这种与问题的大小无关(n的多少)，执行
	时间恒定的算法，我们称之为具有O(1)的时间复杂度，又叫常数阶。

	注意：不管这个常数是多少，我们都记作O(1)，而不是O(3)、O(12)。

	2.9.4 线性阶
	
	int i;
	for(i=0;i<n;i++){
		
		/* 时间复杂度为O(1)的程序步骤序列 */
	}

	2.9.5 对数阶
	
	int count = 1;
	while(count < n){
		count = count*2;
		
		/* 时间复杂度为O(1)的程序步骤序列 */
	}
	由2^x = n得到x = log2n，时间复杂度为O(logn),








