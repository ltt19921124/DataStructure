	第二章
	2.5 算法的特性

	2.5.1 输入输出
	有零个或多个输入，最少一个或多个输出

	2.5.1 有穷性
	执行有限步骤后，会自动结束，不会无限循环

	2.5.2 确定性
	算法每一个步骤都具有确定的意义

	2.5.4 可行性
	算法的每一步都必须是可行的，每一步都能够通过执行有限次数完成
	
	2.6算法设计的要求
  	
  	
	2.6.1 正确性
	正确性是指算法至少应该具有输入、输出和加工处理无歧义性。

	2.6.2 可读性
	便于阅读、理解和交流

	2.6.3 健壮性
	当数据输入不合法时，算法也能做出相关处理，而不是产生异常或莫名其妙的结果

	2.6.4 时间效率高和存储量低
	好的算法还具有时间效率高和存储量低的特点

	2.7算法效率的度量方法
	2.7.1 事后统计方法
	主要是通过设计好的测试程序和数据，利用计算机计时器对不同的算法编制的程序
	的运行时间进行比较，从而确定算法效率的高低	

	2.7.2 事前分析估算方法
	事前分析估算方法：在计算机程序编制前，依据统计方法对算法进行估算
	
	一个程序在计算机上运行时消耗的时间取决于下列因素
	1，算法采用的策略、方法
	2，编译产生的代码质量
	3，问题的输入规模
	4，机器执行指令的速度
	
	2.8 函数的渐进增长
	假设算法A要执行2n+3次操作，算法B要执行3n+1次操作。
	它们谁更快呢？
	
	显然答案不是一定的。
	n=1时，算法A不如算法B。当n=2时，两者效率相同。n>2时，算法A就开始优于算法B了
	随着n的增加，算法A 比算法B越来越好。于是我们得出结论：总体上算法A优于算法B
	此时我们给出这样的定义:输入规模n没有限制的情况下，只要超过一个数值N，这个函数
	就总是大于另一个函数，我们称函数时渐进增长的。

	函数渐进增长：给定两个函数：f(n)和g(n)，如果存在一个整数N，使得对于所有的n>N,
	f(n)总是大于g(n),那么我们说f(n)的增长渐进快于g(n)。

	2.9 算法的时间复杂度

	T(n) = O(f(n)),语句的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化
	情况并确定T(n)的数量级。时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))
	随问题规模n的增大，算法执行时间的增长和f(n)的增长率相同，称作算法的渐进时间复杂度
	简称为时间复杂度。其中f(n)是问题规模n的某个函数。
	大O记法，一般情况下，随着n的增大，T(n）增长最慢的算法为最优算法。

	2.9.2 推到大O阶方法
	1，用常数1取代运行时间中所有的加法常数
	2,在修改后的运行次数函数中，只保留最高阶项
	3，如果最高阶项存在而且不是1，则去除与这个项相乘的常数，得到的结果就是大
	O阶。
	
	2.9.3 常数阶

	int sun = 0;n = 100;//执行一次
	sum = (1+n)*n/2;//执行一次
	printf(" %d ", sum);//执行一次

	这个算法运行次数就是f(n) = 3;根据大O记法，把3改为1，没有最高项阶，所以这个算法的
	时间复杂度为O(1)。

	int sum = 0, n = 100;//一次
	sum = (1+n)*n/2;//执行第1次
	sum = (1+n)*n/2;//执行第2次
	sum = (1+n)*n/2;//执行第3次
	sum = (1+n)*n/2;//执行第4次
	sum = (1+n)*n/2;//执行第5次
	sum = (1+n)*n/2;//执行第6次	
	sum = (1+n)*n/2;//执行第7次
	sum = (1+n)*n/2;//执行第8次
	sum = (1+n)*n/2;//执行第9次
	sum = (1+n)*n/2;//执行第10次
	
	无论n为多少，代码就是3次和12次的差异，这种与问题的大小无关(n的多少)，执行
	时间恒定的算法，我们称之为具有O(1)的时间复杂度，又叫常数阶。

	注意：不管这个常数是多少，我们都记作O(1)，而不是O(3)、O(12)。

	2.9.4 线性阶
	
	int i;
	for(i=0;i<n;i++){
		
		/* 时间复杂度为O(1)的程序步骤序列 */
	}

	2.9.5 对数阶
	
	int count = 1;
	while(count < n){
		count = count*2;
		
		/* 时间复杂度为O(1)的程序步骤序列 */
	}
	由2^x = n得到x = log2n，时间复杂度为O(logn)
	2.9.6 平方阶
	循环嵌套时间复杂度为O(n^2)。
	n*n,如果外层循环次数为m,时间复杂度就为O(m*n)
	
	2.10 常见的时间复杂度
	1，常数阶O(1)
	2，线性阶O(n)
	3, 平方阶O(n^2)
	4, 对数阶O(logn)
	5, nlogn阶
	6，立方阶O(n^3)
	7, 指数阶O(2^n)
	O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)

	2.11 最坏情况和平均情况	
	最坏情况运行时间是一种保证，那就是运行时间将不会再坏了。在应用中，这是一种最重要的
	要求，通常，除非特别指定，我们提到的运行时间都是最坏的运行情况。
	
	而平均运行时间也就是从概率的角度看，这个数字在每一个位置的可能性是相同的，所以平均
	的查找时间为n/2次后发现这个目标元素。

	平均运行时间是所有情况中最优意义的，因为它是期望的运行时间。
	
	一般没有特殊说明的情况下，都是指最坏时间复杂度。

	2.12 算法空间复杂度
	写代码时可以用空间来换取时间，判断某年是否是闰年，可以写小程序（这样每次都要通过计算
	得到是否是闰年的结果），也可以事先建立一个有2050个元素的数组，然后把所有的年份按下
	标的数字对应，如果是闰年，此项数组项的值就是1，如果不是为0，这样问题就成为了查找
	这个数组的某一项的值为多少，这个时候，运算算是最小化了，但是这个数组要消耗一部分
	内存。
	
	这两种策略哪种好呢？其实没有一定的结论，哪一个好，要看用在什么地方。
	
	
	算法空间复杂度公式：S(n) = O(f(n)).n为问题规模，f(n)为语句关于n所占存储空间的函数
	如果算法执行时所需的辅助空间相对于数据量而言是常数，则称此算法为原地工作，空间复杂度	为O(1).

	"时间复杂度"来指运行时间的需求，使用"空间复杂度"指空间需求，当不限定地使用"复杂度"
	时，通常指时间复杂度，我们主要还是分析时间复杂度的问题。


		2.13 总结回顾
		算法定义：算法是解决特定问题的求解步骤的描述，在计算机中为指令的有限列，并且
		每条指令表示一个或多个操作。
		算法特性：有穷性、确定性、可行性、健壮性、高效性和低存储量需求。
		大O记法：
			1.用常数1取代运行时间中的所有加法常数。
			2.在修改的运行次数函数中，只保留最高阶项。
			3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。

		2.14 结尾语

		

		






